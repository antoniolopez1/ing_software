###################TRIGGER FUNCTION-INSERT########################
CREATE OR REPLACE FUNCTION accumulated_hour()
  RETURNS trigger AS
$BODY$
begin

UPDATE salaries SET total_hours = total_hours + new.total_hours, total_extra_hours = total_extra_hours + new.extra_hours, accumulated=(charge_for_hours*(total_hours + new.total_hours))+((total_extra_hours+new.extra_hours)*20000)
WHERE employee_id=new.employee_id;
return new;
end
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.accumulated_hours()
  OWNER TO postgres;
###################TRIGGER- INSERT#############
CREATE TRIGGER ai_hour
  AFTER INSERT
  ON public.hours_histories
  FOR EACH ROW
  EXECUTE PROCEDURE public.accumulated_hour();
###################TRIGGER FUNCTION-UPDATE########################
CREATE OR REPLACE FUNCTION public.accumulated_hours()
  RETURNS trigger AS
$BODY$begin
if new <> old THEN
UPDATE salaries
SET total_hours = total_hours + new.total_hours - old.total_hours, total_extra_hours = total_extra_hours + new.extra_hours - old.extra_hours,
accumulated=(charge_for_hours*(total_hours + new.total_hours - old.total_hours))+((total_extra_hours+ new.extra_hours - old.extra_hours)*20000)
WHERE employee_id=new.employee_id;
end if;
return new;
end
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.accumulated_hours()
  OWNER TO postgres;
###################TRIGGER- UPDATE#############
CREATE TRIGGER bi_hours
  BEFORE UPDATE
  ON public.hours_histories
  FOR EACH ROW
  EXECUTE PROCEDURE public.accumulated_hours();
###################TRIGGERS FUNCTION-INSERT de balance y accumulated############
CREATE OR REPLACE FUNCTION public.balance_employee_payments()
  RETURNS trigger AS
$BODY$begin

UPDATE salaries SET accumulated = new.balance, total_extra_hours = 0, total_hours=new.balance/charge_for_hours
WHERE id=new.salary_id;
return new;
end
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.balance_employee_payments()
  OWNER TO postgres;
#######################TRIGGER INSERT balance ############
CREATE TRIGGER ai_balance
  AFTER INSERT
  ON public.employee_payments
  FOR EACH ROW
  EXECUTE PROCEDURE public.balance_employee_payments();
#######################TRIGGER FUNCTION update balance#########################

CREATE OR REPLACE FUNCTION public.balance_accumulated()
  RETURNS trigger AS
$BODY$begin
if new <> old THEN
UPDATE salaries SET accumulated = (old.amount+old.balance)-new.amount, 
total_extra_hours = 0, 
total_hours=((old.amount+old.balance)-new.amount)/charge_for_hours
WHERE id=new.salary_id;

end if;
return new;
end
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.balance_accumulated()
  OWNER TO postgres;
#######################TRIGGER before update balance###################
CREATE TRIGGER bu_balance
  BEFORE UPDATE
  ON public.employee_payments
  FOR EACH ROW
  EXECUTE PROCEDURE public.balance_accumulated();
#######################TRIGGER Function purchase_total_i###########
CREATE OR REPLACE FUNCTION public.purchase_total()
  RETURNS trigger AS
$BODY$begin
UPDATE purchases SET total=total+new.subtotal, balance=(total+new.subtotal)-amount
WHERE id=new.purchase_id;
return new;
end$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.purchase_total()
  OWNER TO postgres;
#######################TRIGGER ai_purchase_detail#######################
CREATE TRIGGER ai_purchase_detail
  AFTER INSERT
  ON public.purchase_details
  FOR EACH ROW
  EXECUTE PROCEDURE public.purchase_total();
#######################TRIGGER Function purchase_total_u###################
CREATE OR REPLACE FUNCTION public.purchase_total_u()
  RETURNS trigger AS
$BODY$begin
if new <> old THEN
UPDATE purchases SET total = (total-old.subtotal)+new.subtotal, 
balance = ((total-old.subtotal)+new.subtotal)-amount

WHERE id=new.purchase_id;
end if;
return new;
end$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.purchase_total_u()
  OWNER TO postgres;
##########################TRIGGER bu_purchase_detail########################
CREATE TRIGGER bu_purchase_detail
  BEFORE UPDATE
  ON public.purchase_details
  FOR EACH ROW
  EXECUTE PROCEDURE public.purchase_total_u();
###########################TRIGGER Function material quantity###############
CREATE OR REPLACE FUNCTION public.material_quantity_i()
  RETURNS trigger AS
$BODY$begin
UPDATE materials SET quantity=quantity+new.quantity, cost=((new.net_price*new.iva)/100)+new.net_price
WHERE id=new.material_id;
return new;
end$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.material_quantity_i()
  OWNER TO postgres;
#############################TRIGGER ai_purchase_detail in materials#################
CREATE TRIGGER ai_purchase_detail_material
  AFTER INSERT
  ON public.purchase_details
  FOR EACH ROW
  EXECUTE PROCEDURE public.material_quantity_i();

#############################TRIGGER Function material_quantity_u#####################
CREATE OR REPLACE FUNCTION public.material_quantity_u()
  RETURNS trigger AS
$BODY$begin
if new <> old THEN
UPDATE materials SET quantity=(quantity-old.quantity)+new.quantity, cost=((new.net_price*new.iva)/100)+new.net_price
WHERE id=new.material_id;

end if;
return new;
end$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
ALTER FUNCTION public.material_quantity_u()
  OWNER TO postgres;
###############################TRIGGER bu_purchase_detail in materials######
CREATE TRIGGER bu_purchase_detail_material
  BEFORE UPDATE
  ON public.purchase_details
  FOR EACH ROW
  EXECUTE PROCEDURE public.material_quantity_u();



